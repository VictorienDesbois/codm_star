#pragma once

#include "codm_types.hpp"
#include "cca_star.hpp"


namespace std{
  template <> 
  struct hash<Configuration>{
    size_t operator()(const Configuration &val) const{
      return boost::hash_range(val.cbegin(), val.cend());
    }
  };
}


namespace codm_star {

  class SubplannersManager {
    public: 
      SubplannersManager() {}

      /**
       * @brief Constructor for SubplannersManager.
       * 
       * Initializes the SubplannersManager with the given movement graph, communication graph,
       * policies, and optional parameters for logging and conflict checking.
       * 
       * @param movement_graph A shared pointer to the MovesGraph object representing possible movements.
       * @param comm_graph A shared pointer to the CommunicationsGraph object representing communication edges.
       * @param policies A vector of shared pointers to ShortestPaths objects representing movement policies.
       * @param activate_logs A boolean flag indicating whether to activate logging (default is false).
       * @param check_swapping_conflicts A boolean flag indicating whether to check for swapping conflicts (default is false).
       */
      SubplannersManager(
        std::shared_ptr<MovesGraph> movement_graph,
        std::shared_ptr<CommunicationsGraph> comm_graph,
        std::vector<std::shared_ptr<ShortestPaths>> &policies,
        bool activate_logs = false,
        bool check_swapping_conflicts = false
      );


      /**
       * @brief Get a successor generated by the subplanner of a given configuration.
       * 
       * @param ma The MetaAgent for which to find the best successor.
       * @param c The current Configuration of the MetaAgent.
       * @param rand A boolean flag indicating whether to return a random successor (default is false).
       * @return A valid successor of a Configuration.
       */
      Configuration get_successor(MetaAgent &ma, Configuration &c, bool rand = false);


      /**
       * @brief Print the statistics of the nodes explored.
       * 
       * Prints the number of nodes explored by the SubplannersManager.
       * 
       * @param nb_nodes_mainplanner The number of nodes explored by the main planner.
       */
      void print_stats(int nb_nodes_mainplanner);

    private:
      typedef std::unordered_map<Configuration, Configuration> ExploredExecutions;

      // parameters
      bool activate_logs_;
      bool check_swapping_conflicts_;

      // store here the execution computed by the SubplannersManager for each meta agent
      std::unordered_map<MetaAgent, ExploredExecutions> executions_storage_;

      // store here the configuration already visited 
      std::unordered_set<Configuration> config_already_visited_;

      // graphs
      std::shared_ptr<MovesGraph> movement_graph_;
      std::shared_ptr<CommunicationsGraph> comm_graph_;
      
      // agents data
      std::vector<std::shared_ptr<ShortestPaths>> policies_;
      Configuration target_;
      int nb_agents_;
  
      // the subsolver            
      cca_star::CCAstar solver_;

      // planner data
      int subsolver_call = 0;
      int subsolver_success_count = 0;

      // subsolver execution option
      enum { RANDOM, CLASSIC };


      /**
       * @brief Check if the configuration has already been explored.
       * 
       * Determines whether the given configuration for a MetaAgent has already been 
       * explored and is stored in the execution storage.
       * 
       * @param ma The MetaAgent whose configuration is being checked.
       * @param c The Configuration to check for.
       * @return True if the configuration has been explored, false otherwise.
       */
      bool configuration_explored(MetaAgent &ma, Configuration &c);


      /**
       * @brief Validate a configuration relative to its predecessor.
       * 
       * Checks whether the configuration `c` is valid when considering the 
       * predecessor configuration `pred_c`. Will detect collision conflicts 
       * (swapping for instance) and communication conflicts.
       * 
       * @param nb_agents The number of agents involved.
       * @param pred_c The predecessor Configuration.
       * @param c The Configuration to validate.
       * @return True if the configuration is valid, false otherwise.
       */
      bool is_configuration_valid(size_t nb_agents, Configuration &pred_c, Configuration &c);


      /**
       * @brief Checks whether the given execution contains any conflicts among the configurations.
       * 
       * @param e The Execution to validate.
       * @return True if the execution is conflict-free, false otherwise.
       */
      bool is_execution_valid(Execution &e);


      /**
       * @brief Compute an execution using CCA* algorithm.
       * 
       * Computes an execution path for the MetaAgent from the start configuration `s` 
       * to the target configuration `t` using the CCA* algorithm. This method allows 
       * for a specified number of retries and optimization options.
       * 
       * @param s The start Configuration.
       * @param t The target Configuration.
       * @param ma The MetaAgent for which to compute the execution.
       * @param nb_retry The number of retry attempts.
       * @param opt The optimization parameter.
       * @return The computed Execution.
       */
      Execution compute_cca_star(
        Configuration &s, 
        Configuration &t,
        MetaAgent &ma,
        uint64_t nb_retry, 
        uint64_t opt);


      /**
       * @brief Attempt to connect a configuration.
       * 
       * Tries to connect the given configuration `c` if `c` is disconnected. Tries to move
       * some agents to check the communication constraint.
       * 
       * @param c The Configuration to connect.
       * @return An optional Configuration if the connection is successful, empty otherwise.
       */
      std::optional<Configuration> try_to_connect_configuration(Configuration c);


      /**
       * @brief Generate a random configuration.
       * 
       * Generates a random configuration for a specified number of agents.
       * 
       * @param nb_agents The number of agents for which to generate the configuration.
       * @return The generated random Configuration.
       */
      Configuration get_random_config(size_t nb_agents);
  };
  
}